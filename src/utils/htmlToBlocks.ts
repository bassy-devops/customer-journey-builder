import type { EmailBlock } from '../components/email-builder/types';

export const htmlToBlocks = (html: string): EmailBlock[] => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const blocks: EmailBlock[] = [];

    // Check if it's our generated container
    // We look for the max-width: 600px container we usually generate
    // But since users might edit it, we'll try to find the main content wrapper or just parse body children

    // Heuristic: Look for the first div that seems to be a container
    let container = doc.body.querySelector('div[style*="max-width: 600px"]');

    // If no specific container found, use body
    const root = container || doc.body;

    Array.from(root.children).forEach((child) => {
        const block = parseElementToBlock(child as HTMLElement);
        if (block) {
            blocks.push(block);
        }
    });

    // If no blocks were parsed (e.g. text only or empty), create a single HTML block for the whole content
    if (blocks.length === 0 && html.trim().length > 0) {
        return [{
            id: crypto.randomUUID(),
            type: 'html',
            content: { html: html },
            styles: { padding: '0px' }
        }];
    }

    return blocks;
};

const parseElementToBlock = (element: HTMLElement): EmailBlock | null => {
    const style = element.getAttribute('style') || '';
    const blockType = element.getAttribute('data-block-type');

    // 0. Explicit Block Type (Generated by us)
    if (blockType) {
        const paddingMatch = style.match(/padding:\s*([^;]+)/);
        const padding = paddingMatch ? paddingMatch[1].trim() : '10px';

        if (blockType === 'html') {
            return {
                id: crypto.randomUUID(),
                type: 'html',
                content: { html: element.innerHTML },
                styles: { padding }
            };
        }

        if (blockType === 'text') {
            const colorMatch = style.match(/color:\s*([^;]+)/);
            const fontSizeMatch = style.match(/font-size:\s*([^;]+)/);
            const textAlignMatch = style.match(/text-align:\s*([^;]+)/);
            return {
                id: crypto.randomUUID(),
                type: 'text',
                content: { text: element.innerHTML },
                styles: {
                    color: colorMatch ? colorMatch[1].trim() : '#000000',
                    fontSize: fontSizeMatch ? fontSizeMatch[1].trim() : '16px',
                    textAlign: textAlignMatch ? textAlignMatch[1].trim() : 'left',
                    padding
                }
            };
        }

        if (blockType === 'button') {
            const a = element.querySelector('a');
            if (a) {
                const aStyle = a.getAttribute('style') || '';
                const textAlignMatch = style.match(/text-align:\s*([^;]+)/);
                const bgMatch = aStyle.match(/background-color:\s*([^;]+)/);
                const colorMatch = aStyle.match(/color:\s*([^;]+)/);
                const radiusMatch = aStyle.match(/border-radius:\s*([^;]+)/);
                return {
                    id: crypto.randomUUID(),
                    type: 'button',
                    content: {
                        text: a.textContent || 'Button',
                        url: a.getAttribute('href') || '#'
                    },
                    styles: {
                        textAlign: textAlignMatch ? textAlignMatch[1].trim() : 'center',
                        padding,
                        backgroundColor: bgMatch ? bgMatch[1].trim() : '#3b82f6',
                        color: colorMatch ? colorMatch[1].trim() : '#ffffff',
                        borderRadius: radiusMatch ? radiusMatch[1].trim() : '4px'
                    }
                };
            }
        }

        if (blockType === 'image') {
            const img = element.querySelector('img');
            if (img) {
                const widthMatch = img.getAttribute('style')?.match(/width:\s*([^;]+)/);
                return {
                    id: crypto.randomUUID(),
                    type: 'image',
                    content: {
                        src: img.getAttribute('src') || '',
                        alt: img.getAttribute('alt') || ''
                    },
                    styles: {
                        padding,
                        width: widthMatch ? widthMatch[1].trim() : '100%'
                    }
                };
            }
        }

        if (blockType === 'spacer') {
            const heightMatch = style.match(/height:\s*([^;]+)/);
            return {
                id: crypto.randomUUID(),
                type: 'spacer',
                content: {},
                styles: { height: heightMatch ? heightMatch[1].trim() : '20px' }
            };
        }

        if (blockType === 'divider') {
            const hr = element.querySelector('hr');
            const hrStyle = hr?.getAttribute('style') || '';
            const colorMatch = hrStyle.match(/border-top:\s*1px solid\s*([^;]+)/);
            return {
                id: crypto.randomUUID(),
                type: 'divider',
                content: {},
                styles: {
                    color: colorMatch ? colorMatch[1].trim() : '#e2e8f0',
                    padding
                }
            };
        }
    }

    // Fallback Heuristics for external HTML
    // 1. Check for Spacer
    // <div style="height: 20px;"></div>
    if (element.tagName === 'DIV' && element.children.length === 0 && !element.textContent?.trim()) {
        const heightMatch = style.match(/height:\s*([^;]+)/);
        if (heightMatch) {
            return {
                id: crypto.randomUUID(),
                type: 'spacer',
                content: {},
                styles: { height: heightMatch[1].trim() }
            };
        }
    }

    // 2. Check for Divider
    // <div style="padding: ..."><hr ... /></div>
    if (element.tagName === 'DIV' && element.querySelector('hr')) {
        const hr = element.querySelector('hr');
        const hrStyle = hr?.getAttribute('style') || '';
        const colorMatch = hrStyle.match(/border-top:\s*1px solid\s*([^;]+)/);
        const paddingMatch = style.match(/padding:\s*([^;]+)/);

        return {
            id: crypto.randomUUID(),
            type: 'divider',
            content: {},
            styles: {
                color: colorMatch ? colorMatch[1].trim() : '#e2e8f0',
                padding: paddingMatch ? paddingMatch[1].trim() : '10px'
            }
        };
    }

    // 3. Check for Image
    // <div ...><img ... /></div>
    if (element.tagName === 'DIV' && element.querySelector('img')) {
        const img = element.querySelector('img');
        if (img) {
            const paddingMatch = style.match(/padding:\s*([^;]+)/);
            const widthMatch = img.getAttribute('style')?.match(/width:\s*([^;]+)/);

            return {
                id: crypto.randomUUID(),
                type: 'image',
                content: {
                    src: img.getAttribute('src') || '',
                    alt: img.getAttribute('alt') || ''
                },
                styles: {
                    padding: paddingMatch ? paddingMatch[1].trim() : '10px',
                    width: widthMatch ? widthMatch[1].trim() : '100%'
                }
            };
        }
    }

    // 4. Check for Button
    // <div ...><a ...>Text</a></div>
    if (element.tagName === 'DIV' && element.querySelector('a')) {
        const a = element.querySelector('a');
        if (a) {
            const divStyle = element.getAttribute('style') || '';
            const aStyle = a.getAttribute('style') || '';

            const textAlignMatch = divStyle.match(/text-align:\s*([^;]+)/);
            const paddingMatch = divStyle.match(/padding:\s*([^;]+)/);
            const bgMatch = aStyle.match(/background-color:\s*([^;]+)/);
            const colorMatch = aStyle.match(/color:\s*([^;]+)/);
            const radiusMatch = aStyle.match(/border-radius:\s*([^;]+)/);

            return {
                id: crypto.randomUUID(),
                type: 'button',
                content: {
                    text: a.textContent || 'Button',
                    url: a.getAttribute('href') || '#'
                },
                styles: {
                    textAlign: textAlignMatch ? textAlignMatch[1].trim() : 'center',
                    padding: paddingMatch ? paddingMatch[1].trim() : '10px',
                    backgroundColor: bgMatch ? bgMatch[1].trim() : '#3b82f6',
                    color: colorMatch ? colorMatch[1].trim() : '#ffffff',
                    borderRadius: radiusMatch ? radiusMatch[1].trim() : '4px'
                }
            };
        }
    }

    // 5. Check for Text
    // <div ...>Text</div>
    // Heuristic: If it has text content and isn't one of the above
    if (element.tagName === 'DIV' && element.textContent) {
        const colorMatch = style.match(/color:\s*([^;]+)/);
        const fontSizeMatch = style.match(/font-size:\s*([^;]+)/);
        const textAlignMatch = style.match(/text-align:\s*([^;]+)/);
        const paddingMatch = style.match(/padding:\s*([^;]+)/);

        // If it looks like a generic div, treat as text
        return {
            id: crypto.randomUUID(),
            type: 'text',
            content: { text: element.innerHTML }, // Use innerHTML to preserve internal formatting like <b>
            styles: {
                color: colorMatch ? colorMatch[1].trim() : '#000000',
                fontSize: fontSizeMatch ? fontSizeMatch[1].trim() : '16px',
                textAlign: textAlignMatch ? textAlignMatch[1].trim() : 'left',
                padding: paddingMatch ? paddingMatch[1].trim() : '10px'
            }
        };
    }

    // 6. Fallback: Raw HTML
    return {
        id: crypto.randomUUID(),
        type: 'html',
        content: { html: element.outerHTML },
        styles: { padding: '0px' }
    };
};
